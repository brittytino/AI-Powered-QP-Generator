
import React, { useState } from 'react';
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { useToast } from "@/components/ui/use-toast";
import { supabase } from "@/integrations/supabase/client";
import { Check, AlertCircle, FileDown } from "lucide-react";
import { Question, PaperConfig, defaultConfig } from './question-paper/types';
import PaperConfigForm from './question-paper/PaperConfigForm';
import ActionButtons from './question-paper/ActionButtons';
import QuestionCard from './question-paper/QuestionCard';
import SectionConfig from './question-paper/SectionConfig';
import { getQuestionsByFilters, questionAnswers, PrebuiltQuestion } from '@/data/prebuiltQuestions';
import { exportQuestionPaperAsPdf, exportAnswerKeyAsPdf } from '@/utils/pdfExport';
import 'katex/dist/katex.min.css';
import { jsPDF } from 'jspdf';

// Add jsPDF-autotable
import 'jspdf-autotable';
import { useNavigate } from 'react-router-dom';

interface Section {
  name: string;
  marks: number;
  questionCount: number;
}

const QuestionPaperEditor = () => {
  const navigate = useNavigate();
  const [title, setTitle] = useState('');
  const [processing, setProcessing] = useState(false);
  const [questions, setQuestions] = useState<Question[]>([]);
  const [config, setConfig] = useState<PaperConfig>(defaultConfig);
  const [selectedTopic, setSelectedTopic] = useState<string>('');
  const [selectedSubtopics, setSelectedSubtopics] = useState<string[]>([]);
  const [sections, setSections] = useState<Section[]>([
    { name: 'Section A', marks: 20, questionCount: 5 },
    { name: 'Section B', marks: 40, questionCount: 8 },
    { name: 'Section C', marks: 40, questionCount: 4 }
  ]);

  const { toast } = useToast();

  const generateQuestions = async () => {
    if (!selectedTopic || selectedSubtopics.length === 0) {
      toast({
        title: "Missing Information",
        description: "Please select a topic and at least one subtopic.",
        variant: "destructive",
      });
      return;
    }

    try {
      setProcessing(true);
      let generatedQuestions: Question[] = [];
      let totalQuestionsNeeded = sections.reduce((sum, section) => sum + section.questionCount, 0);
      
      console.log('Starting question generation...');
      
      // First try to generate questions using the AI service
      try {
        const sectionsData = sections.map(section => ({
          name: section.name,
          marks: section.marks,
          questionCount: section.questionCount,
          topic: selectedTopic,
          subtopics: selectedSubtopics
        }));
        
        const { data: aiResponse, error: aiError } = await supabase.functions
          .invoke<{ questions: Question[] }>('generate-questions', {
            body: { 
              sections: sectionsData,
              config: config,
              type: 'math'
            }
          });
        
        if (aiError) throw aiError;
        
        if (aiResponse?.questions && aiResponse.questions.length > 0) {
          generatedQuestions = aiResponse.questions;
          console.log('AI generated questions:', generatedQuestions);
        } else {
          throw new Error('No questions generated by AI service');
        }
      } catch (aiError) {
        console.log('AI generation failed, falling back to pre-built questions:', aiError);
        
        // Fallback to pre-built questions
        let sectionQuestions: Question[] = [];
        let questionIndex = 0;
        
        for (const section of sections) {
          // Get pre-built questions for this section
          const prebuiltQuestions = getQuestionsByFilters(
            selectedTopic,
            selectedSubtopics,
            config.difficulty,
            section.questionCount,
            config.educationLevel,
            config.grade
          );
          
          // Convert PrebuiltQuestion to Question
          const sectionQs = prebuiltQuestions.map((pq: PrebuiltQuestion, idx: number) => {
            const answer = questionAnswers[pq.id]?.answer || "See solution for answer";
            const steps = questionAnswers[pq.id]?.steps || ["Detailed solution not available"];
            
            // Assign marks evenly if the total doesn't match
            const questionMarks = Math.round(section.marks / section.questionCount);
            
            return {
              question: pq.question,
              answer: answer,
              steps: steps,
              marks: questionMarks,
              type: pq.type,
              difficulty: pq.difficulty
            };
          });
          
          sectionQuestions = [...sectionQuestions, ...sectionQs];
        }
        
        generatedQuestions = sectionQuestions;
        console.log('Using pre-built questions:', generatedQuestions);
      }
      
      if (generatedQuestions.length > 0) {
        setQuestions(generatedQuestions);
        toast({
          title: "Success!",
          description: "Questions generated successfully.",
        });
      } else {
        throw new Error('Failed to generate questions');
      }
    } catch (error) {
      console.error('Error generating questions:', error);
      toast({
        title: "Error",
        description: "Failed to generate questions. Please try again.",
        variant: "destructive",
      });
    } finally {
      setProcessing(false);
    }
  };

  const handleImageUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    try {
      setProcessing(true);
      
      const formData = new FormData();
      formData.append('file', file);

      const { data: extractedData, error: extractError } = await supabase.functions
        .invoke<{ text: string }>('extract-questions', {
          body: formData
        });

      if (extractError) throw extractError;

      if (extractedData) {
        const { data: aiResponse, error: aiError } = await supabase.functions
          .invoke<{ questions: Question[] }>('generate-questions', {
            body: { 
              content: extractedData.text, 
              config: config,
              type: 'math'
            }
          });

        if (aiError) throw aiError;

        if (aiResponse?.questions) {
          setQuestions(prev => [...prev, ...aiResponse.questions]);
          toast({
            title: "Success!",
            description: "Questions extracted and generated successfully.",
          });
        }
      }
    } catch (error) {
      console.error('Error processing image:', error);
      toast({
        title: "Error",
        description: "Failed to process image. Please try again.",
        variant: "destructive",
      });
    } finally {
      setProcessing(false);
    }
  };

  const shuffleQuestions = () => {
    setQuestions(prevQuestions => {
      const shuffled = [...prevQuestions];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    });
    
    toast({
      title: "Success!",
      description: "Questions shuffled successfully.",
    });
  };

  const downloadPaper = () => {
    if (!title) {
      toast({
        title: "Missing Title",
        description: "Please provide a title for your question paper.",
        variant: "destructive",
      });
      return;
    }
    
    try {
      // Export the question paper (questions only)
      exportQuestionPaperAsPdf(
        questions, 
        {
          title, 
          totalMarks: config.totalMarks, 
          duration: config.duration
        },
        sections
      );
      
      toast({
        title: "Success!",
        description: "Question paper downloaded successfully.",
      });
    } catch (error) {
      console.error('Error downloading paper:', error);
      toast({
        title: "Error",
        description: "Failed to download paper. Please try again.",
        variant: "destructive",
      });
    }
  };

  const downloadAnswerKey = () => {
    if (!title) {
      toast({
        title: "Missing Title",
        description: "Please provide a title for your answer key.",
        variant: "destructive",
      });
      return;
    }
    
    try {
      // Export the answer key with solutions
      exportAnswerKeyAsPdf(
        questions, 
        {
          title, 
          totalMarks: config.totalMarks, 
          duration: config.duration
        },
        sections
      );
      
      toast({
        title: "Success!",
        description: "Answer key downloaded successfully.",
      });
    } catch (error) {
      console.error('Error downloading answer key:', error);
      toast({
        title: "Error",
        description: "Failed to download answer key. Please try again.",
        variant: "destructive",
      });
    }
  };

  const savePaper = async () => {
    if (!title) {
      toast({
        title: "Missing Title",
        description: "Please provide a title for your question paper.",
        variant: "destructive",
      });
      return;
    }
    
    if (questions.length === 0) {
      toast({
        title: "No Questions",
        description: "Please generate questions before saving.",
        variant: "destructive",
      });
      return;
    }
    
    try {
      setProcessing(true);
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user?.id) {
        throw new Error('User not authenticated');
      }

      const paperMetadata = {
        ...config,
        sections: sections,
        topic: selectedTopic,
        subtopics: selectedSubtopics
      };

      const { data: paper, error: paperError } = await supabase
        .from('papers')
        .insert({
          title,
          user_id: user.id,
          metadata: paperMetadata as any
        })
        .select()
        .single();

      if (paperError) throw paperError;

      if (paper) {
        const { error: questionsError } = await supabase
          .from('questions')
          .insert(
            questions.map(q => ({
              paper_id: paper.id,
              content: q.question,
              type: 'math',
              marks: q.marks,
              metadata: { 
                answer: q.answer, 
                steps: q.steps,
                difficulty: q.difficulty,
                questionType: q.type
              }
            }))
          );

        if (questionsError) throw questionsError;

        toast({
          title: "Success!",
          description: "Question paper saved successfully.",
        });
        
        // Navigate to the recent papers page after successful save
        navigate('/recent-papers');
      }
    } catch (error) {
      console.error('Error saving paper:', error);
      toast({
        title: "Error",
        description: "Failed to save paper. Please try again.",
        variant: "destructive",
      });
    } finally {
      setProcessing(false);
    }
  };

  return (
    <div className="space-y-6">
      <Card className="p-6 lg:p-8 bg-white shadow-xl rounded-xl">
        <div className="mb-6">
          <h1 className="text-2xl md:text-3xl font-bold text-gray-800 mb-2">
            Create Question Paper
          </h1>
          <p className="text-gray-600">
            Configure your paper settings and generate questions automatically
          </p>
        </div>

        <PaperConfigForm
          config={config}
          setConfig={setConfig}
          title={title}
          setTitle={setTitle}
          selectedTopic={selectedTopic}
          setSelectedTopic={setSelectedTopic}
          selectedSubtopics={selectedSubtopics}
          setSelectedSubtopics={setSelectedSubtopics}
        />

        <div className="my-6">
          <SectionConfig 
            sections={sections}
            setSections={setSections}
          />
        </div>

        <ActionButtons
          processing={processing}
          generateQuestions={generateQuestions}
          handleImageUpload={handleImageUpload}
          shuffleQuestions={shuffleQuestions}
          downloadPaper={downloadPaper}
          hasQuestions={questions.length > 0}
        />

        {questions.length > 0 && (
          <div className="mt-8 space-y-6">
            <div className="flex justify-between items-center">
              <h2 className="text-xl font-semibold text-gray-800">Generated Questions</h2>
              <div className="flex gap-2">
                <Button 
                  variant="outline" 
                  onClick={downloadPaper}
                  className="flex items-center gap-2"
                >
                  <FileDown className="h-4 w-4" />
                  Download Paper
                </Button>
                <Button 
                  variant="outline" 
                  onClick={downloadAnswerKey}
                  className="flex items-center gap-2"
                >
                  <FileDown className="h-4 w-4" />
                  Download Answer Key
                </Button>
              </div>
            </div>
            
            {sections.map((section, sectionIndex) => {
              // Calculate starting index for this section
              let startingIndex = 0;
              for (let i = 0; i < sectionIndex; i++) {
                startingIndex += sections[i].questionCount;
              }

              // Get questions for this section
              const sectionQuestions = questions.slice(
                startingIndex,
                startingIndex + section.questionCount
              );

              if (sectionQuestions.length === 0) return null;

              return (
                <div key={sectionIndex} className="space-y-4">
                  <h2 className="text-xl font-semibold text-gray-800">
                    {section.name} ({section.marks} marks)
                  </h2>
                  <div className="grid gap-6">
                    {sectionQuestions.map((question, index) => (
                      <QuestionCard
                        key={`${sectionIndex}-${index}`}
                        question={question}
                        index={startingIndex + index}
                      />
                    ))}
                  </div>
                </div>
              );
            })}
          </div>
        )}

        {questions.length > 0 && (
          <div className="mt-8 pt-8 border-t border-gray-200">
            <Button
              onClick={savePaper}
              disabled={!title || questions.length === 0 || processing}
              className="w-full bg-green-600 hover:bg-green-700 text-white py-6 text-lg font-medium rounded-lg transition-colors"
            >
              {processing ? (
                <>
                  <span className="animate-spin mr-2">⏳</span>
                  Saving...
                </>
              ) : (
                <>
                  <Check className="h-5 w-5 mr-2" />
                  Save Question Paper
                </>
              )}
            </Button>
          </div>
        )}
      </Card>
    </div>
  );
};

export default QuestionPaperEditor;
