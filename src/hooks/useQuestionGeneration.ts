
import { useState } from 'react';
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/integrations/supabase/client";
import { Question, PaperConfig } from "@/components/question-paper/types";
import { getQuestionsByFilters, PrebuiltQuestion, questionAnswers } from '@/data/prebuiltQuestions';

interface Section {
  name: string;
  marks: number;
  questionCount: number;
}

export const useQuestionGeneration = () => {
  const [questions, setQuestions] = useState<Question[]>([]);
  const [processing, setProcessing] = useState(false);
  const { toast } = useToast();

  const generateQuestions = async (
    selectedTopic: string,
    selectedSubtopics: string[],
    config: PaperConfig,
    sections: Section[]
  ) => {
    if (!selectedTopic || selectedSubtopics.length === 0) {
      toast({
        title: "Missing Information",
        description: "Please select a topic and at least one subtopic.",
        variant: "destructive",
      });
      return;
    }

    try {
      setProcessing(true);
      let generatedQuestions: Question[] = [];
      let totalQuestionsNeeded = sections.reduce((sum, section) => sum + section.questionCount, 0);
      
      console.log('Starting question generation...');
      
      // First try to generate questions using the AI service
      try {
        const sectionsData = sections.map(section => ({
          name: section.name,
          marks: section.marks,
          questionCount: section.questionCount,
          topic: selectedTopic,
          subtopics: selectedSubtopics
        }));
        
        const { data: aiResponse, error: aiError } = await supabase.functions
          .invoke<{ questions: Question[] }>('generate-questions', {
            body: { 
              sections: sectionsData,
              config: config,
              type: 'math'
            }
          });
        
        if (aiError) throw aiError;
        
        if (aiResponse?.questions && aiResponse.questions.length > 0) {
          generatedQuestions = aiResponse.questions;
          console.log('AI generated questions:', generatedQuestions);
        } else {
          throw new Error('No questions generated by AI service');
        }
      } catch (aiError) {
        console.log('AI generation failed, falling back to pre-built questions:', aiError);
        
        // Fallback to pre-built questions
        let sectionQuestions: Question[] = [];
        let questionIndex = 0;
        
        for (const section of sections) {
          // Get pre-built questions for this section
          const prebuiltQuestions = getQuestionsByFilters(
            selectedTopic,
            selectedSubtopics,
            config.difficulty,
            section.questionCount,
            config.educationLevel,
            config.grade
          );
          
          // Convert PrebuiltQuestion to Question
          const sectionQs = prebuiltQuestions.map((pq: PrebuiltQuestion, idx: number) => {
            const answer = questionAnswers[pq.id]?.answer || "See solution for answer";
            const steps = questionAnswers[pq.id]?.steps || ["Detailed solution not available"];
            
            // Assign marks evenly if the total doesn't match
            const questionMarks = Math.round(section.marks / section.questionCount);
            
            return {
              question: pq.question,
              answer: answer,
              steps: steps,
              marks: questionMarks,
              type: pq.type,
              difficulty: pq.difficulty
            };
          });
          
          sectionQuestions = [...sectionQuestions, ...sectionQs];
        }
        
        generatedQuestions = sectionQuestions;
        console.log('Using pre-built questions:', generatedQuestions);
      }
      
      if (generatedQuestions.length > 0) {
        setQuestions(generatedQuestions);
        toast({
          title: "Success!",
          description: "Questions generated successfully.",
        });
        return true;
      } else {
        throw new Error('Failed to generate questions');
      }
    } catch (error) {
      console.error('Error generating questions:', error);
      toast({
        title: "Error",
        description: "Failed to generate questions. Please try again.",
        variant: "destructive",
      });
      return false;
    } finally {
      setProcessing(false);
    }
  };

  const handleImageUpload = async (event: React.ChangeEvent<HTMLInputElement>, config: PaperConfig) => {
    const file = event.target.files?.[0];
    if (!file) return;

    try {
      setProcessing(true);
      
      const formData = new FormData();
      formData.append('file', file);

      const { data: extractedData, error: extractError } = await supabase.functions
        .invoke<{ text: string }>('extract-questions', {
          body: formData
        });

      if (extractError) throw extractError;

      if (extractedData) {
        const { data: aiResponse, error: aiError } = await supabase.functions
          .invoke<{ questions: Question[] }>('generate-questions', {
            body: { 
              content: extractedData.text, 
              config: config,
              type: 'math'
            }
          });

        if (aiError) throw aiError;

        if (aiResponse?.questions) {
          setQuestions(prev => [...prev, ...aiResponse.questions]);
          toast({
            title: "Success!",
            description: "Questions extracted and generated successfully.",
          });
          return true;
        }
      }
      return false;
    } catch (error) {
      console.error('Error processing image:', error);
      toast({
        title: "Error",
        description: "Failed to process image. Please try again.",
        variant: "destructive",
      });
      return false;
    } finally {
      setProcessing(false);
    }
  };

  const shuffleQuestions = () => {
    setQuestions(prevQuestions => {
      const shuffled = [...prevQuestions];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    });
    
    toast({
      title: "Success!",
      description: "Questions shuffled successfully.",
    });
  };

  return {
    questions,
    setQuestions,
    processing,
    setProcessing,
    generateQuestions,
    handleImageUpload,
    shuffleQuestions
  };
};
